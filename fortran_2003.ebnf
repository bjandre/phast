(* **************************************************************************

grako ebnf grammer for a subset of fortran 2003-ish

Source:
 - "Final Committee Draft" of Fortran Standard 1539-1:2004(E)

 - See Annex D for summary of all grammar urles and constraints.

 - section 1.7.2 for bnf grammar metasyntax description.

 - Rsnn - language syntax rule, section s, rule nn

 - Csnn - rule constraints, section s, constraint nn

 - section referes to the section of the draft standard

Notes:

 - ignoring fixed-format rules.

 - many rule constraints are not implemented(able?) in the EBNF but will be implemented as checks to the parsed code. Search for FIXME.

 * ************************************************************************** *)

(* **************************************************************************
 *
 * keywords (not reservered words?).
 *
 * NOTES:
 *   - section 3.3.1 for keywords that do not have to be separated by whitespace.
 *
 * ************************************************************************** *)

(* free form whitespace rules are contained in section 3.3.1:

Blank characters shall not appear within lexical tokens other than in
a character context or in a format specification.... A blank shall be
used to separate names, constants, or labels from adjacent keywords,
names, constants, or labels.

A sequence of blank characters outside of a character context is
equivalent to a single blank character.

*)

whitespace = " " | "\t";
ws_opt = { whitespace }*;
ws_req = { whitespace }+;

end_of_line = ws_opt { "\n" | "\r" | "\n\r" }+ ;

(* FIXME(bja, 201412 ) should account for continuation
lines...? *)

rparen       = ")"      ws_opt (continuation | eos);
lparen       = "(" !"/" ws_opt continuation ;
forwardslash = "/" !")" ws_opt continuation ;
comma        = ","      ws_opt continuation ;
colon        = ":" !":" ws_opt continuation ;
coloncolon   = "::"     ws_opt continuation ;
asterisk     = "*"      ws_opt continuation ;
percent      = "%"      ws_opt continuation ;
equal        = "=" !">" ws_opt continuation ;
arrow        = "=>"     ws_opt continuation ;
plus         = "+"      ws_opt continuation ;
minus        = "-"      ws_opt continuation ;

(* only used in special characters, don't want continuation? *)
backslash         = "\\" ;
quote             = '"'  ; (* " fix broken syntax highlighting *)
lsquare           = "["  ;
rsquare           = "]"  ;
lcurly            = "{"  ;
rcurly            = "}"  ;
decimal_point     = "."  ;
semicolon         = ";"  ;
exclamation_point = "!"  ;
ampersand         = "&"  ;
tilde             = "~"  ;
less_than         = "<"  ;
greater_than      = ">"  ;
question_mark     = "?"  ;
apostrophe        = "'"  ;
grave_accent      = "`"  ;
circumflex_accent = "^"  ;
vertical_line     = "|"  ;
currency_symbol   = "$"  ;
number_sign       = "#"  ;
commercial_at     = "@"  ;

(*NOTE(bja, 201502) need for escaping in string literals. *)
double_quote = '""'
             ;

double_apostrophe = "''"
                  ;

(* section 3.3.1.1 *)
comment_char = exclamation_point ;

comment = { { { ws_opt }* comment_char {character | ws_opt}* }* end_of_line }* ;

(* section 3.3.1.2 *)
continuation_char = ampersand ;

continuation = { continuation_char ( end_of_line | comment) }*;

(* section 3.3.1.3 *)
(* end of statement *)
eos = semicolon | comment | end_of_line ;

block_data_keyword       = ( "block data"       | "blockdata"       ) continuation;
double_precision_keyword = ( "double precision" | "doubleprecision" ) continuation;
else_if_keyword          = ( "else if"          | "elseif"          ) continuation;
else_where_keyword       = ( "else where"       | "elsewhere"       ) continuation;
end_associate_keyword    = ( "end associate"    | "endassociate"    ) continuation;
end_block_data_keyword   = ( "end block data"   | "endblockdata"    ) continuation;
end_do_keyword           = ( "end do"           | "enddo"           ) continuation;
end_enum_keyword         = ( "end enum"         | "endenum"         ) continuation;
end_file_keyword         = ( "end file"         | "endfile"         ) continuation;
end_forall_keyword       = ( "end forall"       | "endforall"       ) continuation;
end_function_keyword     = ( "end function"     | "endfunction"     ) continuation;
end_if_keyword           = ( "end if"           | "endif"           ) continuation;
end_interface_keyword    = ( "end interface"    | "end_interface"   ) continuation;
end_module_keyword       = ( "end module"       | "endmodule"       ) continuation;
end_program_keyword      = ( "end program"      | "endprogram"      ) continuation;
end_select_keyword       = ( "end select"       | "endselect"       ) continuation;
end_subroutine_keyword   = ( "end subroutine"   | "end subroutine"  ) continuation;
end_type_keyword         = ( "end type"         | "endtype"         ) continuation;
end_where_keyword        = ( "end where"        | "endwhere"        ) continuation;
go_to_keyword            = ( "go to"            | "goto"            ) continuation;
in_out_keyword           = ( "in out"           | "inout"           ) continuation;
select_case_keyword      = ( "select case"      | "selectcase"      ) continuation;
select_type_keyword      = ( "select type"      | "select type"     ) continuation;

double_keyword          = double_precision_keyword continuation;

abstract_keyword        = "abstract"        ws_req continuation;
access_keyword          = "access"          ws_req continuation;
action_keyword          = "action"          ws_req continuation;
advance_keyword         = "advance"         ws_req continuation;
allocatable_keyword     = "allocatable"     ws_req continuation;
allocate_keyword        = "allocate"        ws_req continuation;
assignment_keyword      = "assignment"      ws_req continuation;
associate_keyword       = "associate"       ws_req continuation;
asynchronous_keyword    = "asynchronous"    ws_req continuation;
backspace_keyword       = "backspace"       ws_req continuation;
bind_keyword            = "bind"            ws_req continuation;
blank_keyword           = "blank"           ws_req continuation;
c_keyword               = "c"               ws_req continuation;
call_keyword            = "call"            ws_req continuation;
case_keyword            = "case"            ws_req continuation;
character_keyword       = "character"       ws_req continuation;
class_keyword           = "class"           ws_req continuation;
close_keyword           = "close"           ws_req continuation;
common_keyword          = "common"          ws_req continuation;
complex_keyword         = "complex"         ws_req continuation;
contains_keyword        = "contains"        ws_opt             ; (* NOTE(bja, 201501) : can't have a continuation...? *)
continue_keyword        = "continue"        ws_req continuation;
cycle_keyword           = "cycle"           ws_req continuation;
data_keyword            = "data"            ws_req continuation;
deallocate_keyword      = "deallocate"      ws_req continuation;
decimal_keyword         = "decimal"         ws_req continuation;
default_keyword         = "default"         ws_req continuation;
deffered_keyword        = "deferred"        ws_req continuation;
delim_keyword           = "delim"           ws_req continuation;
dimension_keyword       = "dimension"       ws_req continuation;
direct_keyword          = "direct"          ws_req continuation;
do_keyword              = "do"              ws_req continuation;
elemental_keyword       = "elemental"       ws_req continuation;
else_keyword            = "else"            ws_req continuation;
encoding_keyword        = "encoding"        ws_req continuation;
end_keyword             = "end"             ws_req continuation;
entry_keyword           = "entry"           ws_req continuation;
enum_keyword            = "enum"            ws_req continuation;
enumerator_keyword      = "enumerator"      ws_req continuation;
eor_keyword             = "eor"             ws_req continuation;
equivalence_keyword     = "equivalence"     ws_req continuation;
err_keyword             = "err"             ws_req continuation;
errmsg_keyword          = "errmsg"          ws_req continuation;
exist_keyword           = "exist"           ws_req continuation;
exit_keyword            = "exit"            ws_req continuation;
extends_keyword         = "extends"         ws_req continuation;
external_keyword        = "external"        ws_req continuation;
file_keyword            = "file"            ws_req continuation;
final_keyword           = "final"           ws_req continuation;
flush_keyword           = "flush"           ws_req continuation;
fmt_keyword             = "fmt"             ws_req continuation;
forall_keyword          = "forall"          ws_req continuation;
form_keyword            = "form"            ws_req continuation;
format_keyword          = "format"          ws_req continuation;
formatted_keyword       = "formatted"       ws_req continuation;
function_keyword        = "function"        ws_req continuation;
generic_keyword         = "generic"         ws_req continuation;
id_keyword              = "id"              ws_req continuation;
if_keyword              = "if"              ws_req continuation;
implicit_keyword        = "implicit"        ws_opt continuation;
import_keyword          = "import"          ws_req continuation;
in_keyword              = "in"              ws_req continuation;
inquire_keyword         = "inquire"         ws_req continuation;
integer_keyword         = "integer"         ws_req continuation;
intent_keyword          = "intent"          ws_req continuation;
interface_keyword       = "interface"       ws_req continuation;
intrinsic_keyword       = "intrinsic"       ws_req continuation;
iolength_keyword        = "iolength"        ws_req continuation;
iomsg_keyword           = "iomsg"           ws_req continuation;
iostat_keyword          = "iostat"          ws_req continuation;
is_keyword              = "is"              ws_req continuation;
kind_keyword            = "kind"            ws_req continuation;
length_keyword          = "len"             ws_req continuation;
logical_keyword         = "logical"         ws_req continuation;
module_keyword          = "module"          ws_req continuation;
name_keyword            = "name"            ws_req continuation;
named_keyword           = "named"           ws_req continuation;
namelist_keyword        = "namelist"        ws_req continuation;
nextrec_keyword         = "nextrec"         ws_req continuation;
nml_keyword             = "nml"             ws_req continuation;
non_intrinsic_keyword   = "non intrinsic"   ws_req continuation;
non_overridable_keyword = "non_overridable" ws_req continuation;
none_keyword            = "none"            ws_opt continuation;
nopass_keyword          = "nopass"          ws_req continuation;
nullify_keyword         = "nullify"         ws_req continuation;
number_keyword          = "number"          ws_req continuation;
only_keyword            = "only"            ws_req continuation;
open_keyword            = "open"            ws_req continuation;
opened_keyword          = "opened"          ws_req continuation;
operator_keyword        = "operator"        ws_req continuation;
optional_keyword        = "optional"        ws_req continuation;
out_keyword             = "out"             ws_req continuation;
pad_keyword             = "pad"             ws_req continuation;
parameter_keyword       = "parameter"       ws_req continuation;
pass_keyword            = "pass"            ws_req continuation;
pending_keyword         = "pending"         ws_req continuation;
pointer_keyword         = "pointer"         ws_req continuation;
pos_keyword             = "pos"             ws_req continuation;
position_keyword        = "position"        ws_req continuation;
print_keyword           = "print"           ws_req continuation;
private_keyword         = "private"         ws_req continuation;
procedure_keyword       = "procedure"       ws_req continuation;
program_keyword         = "program"         ws_req continuation;
protected_keyword       = "protected"       ws_req continuation;
public_keyword          = "public"          ws_req continuation;
pure_keyword            = "pure"            ws_req continuation;
read_keyword            = "read"            ws_req continuation;
readwrite_keyword       = "readwrite"       ws_req continuation;
real_keyword            = "real"            ws_req continuation;
rec_keyword             = "rec"             ws_req continuation;
recl_keyword            = "recl"            ws_req continuation;
recursive_keyword       = "recursive"       ws_req continuation;
result_keyword          = "result"          ws_opt continuation;
return_keyword          = "return"          ws_req continuation;
rewind_keyword          = "rewind"          ws_req continuation;
round_keyword           = "round"           ws_req continuation;
save_keyword            = "save"            ws_req continuation;
select_keyword          = "select"          ws_req continuation;
sequence_keyword        = "sequence"        ws_req continuation;
sequential_keyword      = "sequential"      ws_req continuation;
sign_keyword            = "sign"            ws_req continuation;
size_keyword            = "size"            ws_req continuation;
source_keyword          = "source"          ws_req continuation;
stat_keyword            = "stat"            ws_req continuation;
status_keyword          = "status"          ws_req continuation;
stop_keyword            = "stop"            ws_req continuation;
stream_keyword          = "stream"          ws_req continuation;
subroutine_keyword      = "subroutine"      ws_req continuation;
target_keyword          = "target"          ws_req continuation;
then_keyword            = "then"            ws_req continuation;
type_keyword            = "type"            ws_req continuation;
unformatted_keyword     = "unformatted"     ws_req continuation;
unit_keyword            = "unit"            ws_req continuation;
use_keyword             = "use"             ws_req continuation;
value_keyword           = "value"           ws_req continuation;
volatile_keyword        = "volatile"        ws_req continuation;
wait_keyword            = "wait"            ws_req continuation;
where_keyword           = "where"           ws_req continuation;
while_keyword           = "while"           ws_req continuation;
write_keyword           = "write"           ws_req continuation;

keywords =
           "abstract"
         | "access"
         | "action"
         | "advance"
         | "allocatable"
         | "allocate"
         | "assignment"
         | "associate"
         | "asynchronous"
         | "backspace"
         | "bind"
         | "blank"
         | "c"
         | "call"
         | "case"
         | "character"
         | "class"
         | "close"
         | "common"
         | "complex"
         | "contains"
         | "continue"
         | "cycle"
         | "data"
         | "deallocate"
         | "decimal"
         | "default"
         | "deferred"
         | "delim"
         | "dimension"
         | "direct"
         | "do"
         | "elemental"
         | "else"
         | "encoding"
         | "end"
         | "entry"
         | "enum"
         | "enumerator"
         | "eor"
         | "equivalence"
         | "err"
         | "errmsg"
         | "exist"
         | "exit"
         | "extends"
         | "external"
         | "file"
         | "final"
         | "flush"
         | "fmt"
         | "forall"
         | "form"
         | "format"
         | "formatted"
         | "function"
         | "generic"
         | "id"
         | "if"
         | "implicit"
         | "import"
         | "in"
         | "inquire"
         | "integer"
         | "intent"
         | "interface"
         | "intrinsic"
         | "iolength"
         | "iomsg"
         | "iostat"
         | "is"
         | "kind"
         | "len"
         | "logical"
         | "module"
         | "name"
         | "named"
         | "namelist"
         | "nextrec"
         | "nml"
         | "non intrinsic"
         | "non_overridable"
         | "none"
         | "nopass"
         | "nullify"
         | "number"
         | "only"
         | "open"
         | "opened"
         | "operator"
         | "optional"
         | "out"
         | "pad"
         | "parameter"
         | "pass"
         | "pending"
         | "pointer"
         | "pos"
         | "position"
         | "print"
         | "private"
         | "procedure"
         | "program"
         | "protected"
         | "public"
         | "pure"
         | "read"
         | "readwrite"
         | "real"
         | "rec"
         | "recl"
         | "recursive"
         | "result"
         | "return"
         | "rewind"
         | "round"
         | "save"
         | "select"
         | "sequence"
         | "sequential"
         | "sign"
         | "size"
         | "source"
         | "stat"
         | "status"
         | "stop"
         | "stream"
         | "subroutine"
         | "target"
         | "then"
         | "type"
         | "unformatted"
         | "unit"
         | "use"
         | "value"
         | "volatile"
         | "wait"
         | "where"
         | "while"
         | "write"
         ;


(* **************************************************************************
 *
 * section 1
 *
 * ************************************************************************** *)

(* assumed syntax
R101 xyz_list = xyz [ , xyz ] ...
R102 xyz-name = name
R103 scalar-xyz = xyz


*)


(* **************************************************************************
 *
 * section 2
 *
 * ************************************************************************** *)

(* R201 *)
program = { program_unit }+
        ;

(* R202 *)
program_unit = main_program |
              external_subprogram |
              module |
              block_data
              ;

(* R203 *)
external_subprogram = function_subprogram |
                     subroutine_subprogram
                     ;


(* R204 *)
specification_part = { use_stmt }*
                   { import_stmt }*
                   [ implicit_part ]
                   { declaration_construct }*
                   ;

(* R205 : NOTE(bja, 201501) R205 and R206 as stated in standard doesn't allow a single implicit stmt (e.g. implicit none). *)
implicit_part = ws_opt { implicit_part_stmt }* { implicit_stmt }+
               ;

(* R206 : *)
implicit_part_stmt = parameter_stmt
                    | format_stmt
                    | entry_stmt
                    ;

(* R207 *)
declaration_construct = derived_type_def
                      | entry_stmt
                      | enum_def
                      | format_stmt
                      | interface_block
                      | parameter_stmt
                      | procedure_declaration_stmt
                      | specification_stmt
                      | type_declaration_stmt
                      | stmt_function_stmt
                       ;

(* R208 *)
execution_part = executable_construct
                { execution_part_construct }*
                ;

(* R209 *)
execution_part_construct = executable_construct |
                          format_stmt |
                          entry_stmt |
                          data_stmt
                          ;

(* R210  *)
internal_subprogram_part = contains_stmt
                         { internal_subprogram }+
                         ;
(* R211  *)
internal_subprogram = function_subprogram
                    | subroutine_subprogram
                    ;

(* R212  *)
specification_stmt = access_stmt
                   | allocatable_stmt
                   | asynchronous_stmt
                   | bind_stmt
                   | common_stmt
                   | data_stmt
                   | dimension_stmt
                   | equivalence_stmt
                   | external_stmt
                   | intent_stmt
                   | intrinsic_stmt
                   | namelist_stmt
                   | optional_stmt
                   | pointer_stmt
                   | protected_stmt
                   | save_stmt
                   | target_stmt
                   | volatile_stmt
                   | value_stmt
                   ;

(* R213 *)
executable_construct = action_stmt
                     | associate_construct
                     | case_construct
                     | do_construct
                     | forall_construct
                     | if_construct
                     | select_type_construct
                     | where_construct
                     ;

(* R214 : NOTE(bja, 201412) per C201, end_function_stmt,
end_program_stmt and end_subroutine_stmt removed. *)

action_stmt = ( allocate_stmt
            | assignment_stmt
            | backspace_stmt
            | call_stmt
            | close_stmt
            | continue_stmt
            | cycle_stmt
            | deallocate_stmt
            | endfile_stmt
(*            | end_function_stmt
            | end_program_stmt
            | end_subroutine_stmt *)
            | exit_stmt
            | flush_stmt
            | forall_stmt
            | goto_stmt
            | if_stmt
            | inquire_stmt
            | nullify_stmt
            | open_stmt
            | pointer_assignment_stmt
            | print_stmt
            | read_stmt
            | return_stmt
            | rewind_stmt
            | stop_stmt
            | wait_stmt
            | where_stmt
            | write_stmt
            | arithmetic_if_stmt
            | computed_goto_stmt ) eos
            ;


(* **************************************************************************
 *
 * section 3.1 - processor character set
 *
 * ************************************************************************** *)
letter = /[a-zA-Z]/ ;

digit = /[0-9]/ ;

space = /[ \t]/ ;

(* R303 *)
underscore = /_/ ;

(* table 3.1

NOTE(bja, 201501) add '=', ':', '/', '(/' here manualy because rule includes a
check for invalid combanitions in statements that are valid in
comments!

NOTE(bja, 201502) remove quote and apostrophe because they can't be in
double quoted or single quoted string literals respectively.

*)

special_character = space
                  | "="
                  | plus
                  | minus
                  | asterisk
                  | "/"
                  | backslash
                  | "(" | rparen
                  | lsquare | rsquare
                  | lcurly | rcurly
                  | comma
                  | decimal_point
                  | ":"
                  ! semicolon
                  | exclamation_point
                  | percent
                  | ampersand
                  | tilde
                  | less_than
                  | greater_than
                  | question_mark
                  | grave_accent
                  | circumflex_accent
                  | vertical_line
                  | currency_symbol
                  | number_sign
                  | commercial_at
                  ;

(* R301 : NOTE(bja, 201502) moved quote and apsotrophe here from special character. *)
character = alphanumeric_character
          | special_character
          | quote
          | apostrophe
          ;

(* NOTE(bja, 201502) created to handle single quoted string literals *)
single_quote_character = alphanumeric_character
             | special_character
             | quote
             | double_apostrophe
             ;

(* NOTE(bja, 201502) created to handle double quoted string literals *)
double_quote_character = alphanumeric_character
             | special_character
             | apostrophe
             | double_quote
             ;

(* R302 *)
alphanumeric_character = letter
                         | digit
                         | underscore
                       ;

(* **************************************************************************
 *
 * section 3.2 - low level syntax
 *
 * ************************************************************************** *)
(* R304, FIXME(bja, 201412) C301 for R304 - max name length is 64 characters *)
name =
     letter
     { alphanumeric_character }*
     ;

(*  section 3.2.2 - constants  *)
(* R305 *)
scalar_constant = constant
;

constant = ( literal_constant
         | named_constant) ws_req
         ;

(* R306 *)
literal_constant = complex_literal_constant
                 | real_literal_constant
                 | int_literal_constant
                 | logical_literal_constant
                 | char_literal_constant
                 | boz_literal_constant
                 ;

(* R307 *)
named_constant = name
               ;

(* R308, FIXME(bja, 2014_12) C302 int constant shall be of type integer *)
scalar_int_constant = int_constant
;

int_constant = constant
             ;

(* R309, FIXME(bja, 2014_12) C303 char constant shall be of type character *)
scalar_char_constant = char_constant
;

char_constant = constant
              ;

(*  section 3.2.3 - operators  *)
(* R310 *)
intrinsic_operator = power_op
                   | mult_op
                   | add_op
                   | concat_op
                   | rel_op
                   | not_op
                   | and_op
                   | or_op
                   | equiv_op
                   ;

(* R311 *)
defined_operator = defined_unary_op
                 | defined_binary_op
                 | extended_intrinsic_op
                 ;

(* R312 *)
extended_intrinsic_op = intrinsic_operator
                      ;

(* R313 : C 304 *)
label_list = label { comma label }*
;

label = digit [digit [digit [digit [digit ]]]]
      ;


(* delimiters (...) /.../ [...] (/.../) *)
(* FIXME(bja 2014_12) not sure what to do with these... *)

(* section 3.4 - not a fortran statement, preprocessor *)
include_line = "include" char_literal_constant end_of_line
             ;



(* **************************************************************************
 *
 * section 4 : types
 *
 * ************************************************************************** *)
(* R401 *)
type_spec = intrinsic_type_spec
          | derived_type_spec
          ;

(* R402 : FIXME(bja, 2014_12) C402 and C403 (":" deferred type
parameter, only in declaration or pointer/allocatable) "*" assumed
type parameter *)

type_param_value = scalar_int_expr
                 | asterisk
                 | colon
                 ;

intrinsic_type_spec = (integer_keyword [ kind_selector ])
                    | (real_keyword [ kind_selector ])
                    | double_keyword
                    | (complex_keyword [ kind_selector ] )
                    | (character_keyword [ char_selector ] )
                    | (logical_keyword [ kind_selector ] )
                    ;

(* R404 : FIXME(bja, 2014_12) C404 scalar_int_initialization_expr nonnegative *)
kind_str = kind_keyword equal
         ;

kind_selector = lparen [ kind_str ] scalar_int_initialization_expr rparen
              ;

(* R405 *)
signed_int_literal_constant = [ sign ] int_literal_constant
                            ;

(* R406 *)
scalar_int_literal_constant = int_literal_constant
;

int_literal_constant = digit_string [ underscore kind_constant ]
                     ;

(* R407 C405 - scalar_int_constant_name shall be a named constant of type int; C406 - kind_param sholl be nonnegative *)
scalar_int_constant_name = name
;

kind_param = digit_string
           | scalar_int_constant_name
           ;

kind_constant = underscore kind_param
              ;

(* R408 *)
signed_digit_string = [ sign ] digit_string
                    ;

(* R409 *)
digit_string = { digit }+
             ;

(* R410 *)
sign = plus | minus
     ;

(* R411 : C410 *)
boz_literal_constant = binary_constant
                     | octal_constant
                     | hex_constant
                     ;

(* R412 : C *)
binary_digit = "0" | "1"
             ;
binary_constant = ("b" apostrophe { binary_digit }+ apostrophe)
                | ("b" quote { binary_digit }+ quote)
                ;

(* R413 : C *)
octal_digit = "0" | "1" | "2" | "3"
            | "4" | "5" | "6" | "7"
            ;
octal_constant = ("o" apostrophe { octal_digit }+ apostrophe)
                | ("o" quote { octal_digit }+ quote)
                ;

(* R414 *)
hex_constant = ("z" apostrophe { hex_digit }+ apostrophe)
                | ("z" quote { hex_digit }+ quote)
                ;

(* R415 *)
hex_digit = digit
          | "a"
          | "b"
          | "c"
          | "d"
          | "e"
          | "f"
          ;

(* R416 *)
signed_real_literal_constant = [ sign ] real_literal_constant
                             ;

(* R417 FIXME(bja, 2014_12) if both kind_constant and exponent_letter, exponent letter sh all be 'E' *)
real_literal_constant = (significand [ exponent_letter exponent ] [ kind_constant ])
                      | (digit_string exponent_letter exponent [ kind_constant ])
                      ;

(* R418 *)
significand = (digit_string decimal_point digit_string)
            | (decimal_point digit_string)
            ;

(* R419 *)
exponent_letter = "e" | "d"
                ;

(* R420 *)
exponent = signed_digit_string
         ;

(* R421 FIXME(bja, 2014_12) each named constant shall be of type integer or real *)
complex_literal_constant = lparen real_part comma imag_part rparen
                         ;

(* R422 *)
real_part = signed_int_literal_constant
          | signed_real_literal_constant
          | named_constant
          ;

(* R423 *)
imag_part = signed_int_literal_constant
          | signed_real_literal_constant
          | named_constant
          ;

(* R424 : C414, C416, C421 *)
char_selector = length_selector
              | (lparen length_str type_param_value comma kind_str scalar_int_initialization_expr rparen)
              | (lparen type_param_value comma [ kind_str ] scalar_int_initialization_expr rparen)
              | (lparen kind_str scalar_int_initialization_expr [comma length_str type_param_value] rparen)
              ;

(* R425 : C416, C419, C420 not implemented *)
length_str = length_keyword equal
         ;

length_selector = (lparen [ length_str ] type_param_value rparen)
                | (asterisk char_length [comma])
              ;

(* R426 : C415, C416 *)
char_length = lparen type_param_value rparen
            | scalar_int_literal_constant
            ;

(* R427 : C422 *)
char_literal_constant = ( [ kind_param underscore] apostrophe { single_quote_rep_char }* apostrophe )
                      | ( [ kind_param underscore] quote { double_quote_rep_char }* quote )
                      ;

single_quote_rep_char = single_quote_character
                      ;

double_quote_rep_char = double_quote_character
                      ;

rep_char = character
         ;

(* R428 *)
true_str = ".true."
         ;

false_str = ".false."
          ;

logical_literal_constant = (true_str [ underscore kind_param ])
                         | (false_str [ underscore kind_param ])
                         ;

(* R429 : C427 C428 C429 *)
derived_type_def = derived_type_stmt
                     { type_param_def_stmt }*
                     { private_or_sequence }*
                     { component_part }*
                     { type_bound_procedure_part }*
                 end_type_stmt
                 ;

(* R430 : C424 C425 C430 *)
type_name = name
;

derived_type_stmt = type_keyword [ [ comma type_attr_spec_list ] coloncolon ] type_name [ lparen type_param_name_list rparen ] eos
                  ;

(* R431 : C426 *)
type_attr_spec_list = type_attr_spec { comma type_attr_spec }*
                    ;

parent_type_name = name
;

type_attr_spec = access_spec
               | ( extends_keyword lparen parent_type_name rparen )
               | abstract_keyword
               | bind_keyword lparen c_keyword rparen
               ;

(* R432 *)
private_or_sequence = private_components_stmt
                    | sequence_stmt
                    ;

(* R433 : C431 - if typename, then it much match the name in derived type *)
end_type_stmt = end_type_keyword [ type_name ] eos
                   ;

(* R434 : C432 C433 *)
sequence_stmt = sequence_keyword eos
              ;

(* R435 : C434 C435 *)
type_param_def_stmt = integer_keyword [ kind_selector ] comma type_param_attr_spec coloncolon type_param_decl_list eos
                    ;

(* R436 *)
type_param_name_list = type_param_name { comma type_param_name }*
;

type_param_name = name
                ;

type_param_decl_list = type_param_decl { comma type_param_decl }*
;

type_param_decl = type_param_name [ equal scalar_int_initialization_expr ]
                ;

(* R437 *)
type_param_attr_spec = kind_keyword
                     | length_keyword
                     ;

(* R438 *)
component_part = { component_def_stmt }*
               ;

(* R439 : C445 *)
component_def_stmt = data_component_def_stmt
                   | proc_component_def_stmt
                   ;

(* R440 : C436 C437 C438 C439 C440 C441 C443 C446 C447 *)
data_component_def_stmt = declaration_type_spec [ [ comma component_attr_spec_list ] coloncolon ] component_decl_list eos
                        ;

(* R441 *)
component_attr_spec_list = component_attr_spec { comma component_attr_spec }*
;

component_attr_spec = pointer_keyword
                    | ( dimension_keyword lparen component_array_spec rparen )
                    | allocatable_keyword
                    | access_spec
                    ;

(* R442 : C444 *)
component_decl_list = component_decl { comma component_decl }*
;

component_decl = component_name [ lparen component_array_spec rparen ] [ asterisk char_length ] [ component_initialization ]
               ;

component_name = name
;


(* R443 : C442 *)
component_array_spec = explicit_shape_spec_list
                     | deferred_shape_spec_list
                     ;

(* R444 *)
component_initialization = initialization_expr
                         | arrow null_init
                         ;


(* R445 : C448, C449, C450, C451, C452*)
proc_component_def_stmt = procedure_keyword lparen [ proc_interface ] rparen comma proc_component_attr_spec_list coloncolon proc_decl_list eos
                        ;

(* R446 *)
proc_component_attr_spec_list = proc_component_attr_spec { comma proc_component_attr_spec }*
;

proc_component_attr_spec = pointer_keyword
                         | (pass_keyword [ lparen arg_name rparen ])
                         | nopass_keyword
                         | access_spec
                         ;

arg_name = name
;


(* R447 : C454 *)
private_components_stmt = private_keyword eos
                        ;


(* R448 : C455 *)
type_bound_procedure_part = contains_stmt [ binding_private_stmt ] { proc_binding_stmt }+
                          ;
(* R449 *)
binding_private_stmt = private_keyword eos
                     ;

(* R450 *)
proc_binding_stmt = ( specific_binding
                  | generic_binding
                  | final_binding )
                  eos
                  ;

(* R451 : C456, C457, C458, C466, C467, C471, C472 *)
specific_binding = procedure_keyword [ lparen interface_name rparen ] [ [ comma binding_attr_list ] coloncolon ] binding_name [ arrow procedure_name ]
                 ;

(* R452 : C549, C460, C461, C462, C463, C464 *)
binding_name = name
             ;

binding_name_list = binding_name { comma binding_name }*
                  ;

generic_binding = generic_keyword [ comma access_spec ] coloncolon generic_spec arrow binding_name_list
                ;


(* R453 : C465, C468, C469, C470 *)
binding_attr_list = binding_attr { comma binding_attr }*
;

binding_attr = ( pass_keyword [ lparen arg_name rparen ] )
             | nopass_keyword
             | non_overridable_keyword
             | deffered_keyword
             | access_spec
             ;

(* R454 : C473 C474 C475 *)
final_binding = final_keyword [ coloncolon ] final_subroutine_name_list
              ;

final_subroutine_name_list = final_subroutine_name { comma final_subroutine_name }*
                           ;

final_subroutine_name = name
                      ;



(* R455 : C476 C477 C478 *)
derived_type_spec = type_name [ lparen type_param_spec_list rparen ]
                  ;

(* R456 : C479 C480 C481 *)
type_param_spec_list = type_param_spec { comma type_param_spec }*
;

keyword = name
        ;

type_param_spec = [ keyword equal ] type_param_value
                ;

(* R457 : C482 C483 C484 C485 C488 C489 *)
structure_constructor = derived_type_spec lparen [ component_spec_list ] rparen
                      ;
(* R458 : C486 C487 *)
component_spec_list = component_spec { comma component_spec }*
;

component_spec = [ keyword equal ] component_data_source
               ;

(* R459 : C490 C491 *)
component_data_source = expr
                      | data_target
                      | proc_target
                      ;

(* R460 *)
enum_def = enum_def_stmt { enumerator_def_stmt }+
         end_enum_stmt
         ;

(* R461 *)
enum_def_stmt = enum_keyword comma bind_keyword lparen c_keyword rparen eos
              ;

(* R462 : C492 *)
enumerator_def_stmt = enumerator_keyword [ coloncolon ] enumerator_list eos
                    ;

(* R463 *)
enumerator_list = enumerator { comma enumerator }*
;

enumerator = named_constant [ equal scalar_int_initialization_expr ]
           ;

(* R464 *)
end_enum_stmt = end_enum_keyword eos
              ;

(* R465 *)
array_constructor = ( "(/" ac_spec "/)" )
                  | ( left_square_bracket ac_spec right_square_bracket )
                  ;

(* R466 : C494 C495 C496 *)
ac_spec = ( type_spec coloncolon )
        | ( [ type_spec coloncolon ] ac_value_list )
        ;

(* R467 *)
left_square_bracket = "["
                    ;

(* R468 *)
right_square_bracket = "]"
                     ;

(* R469 *)
ac_value_list = ac_value { comma ac_value }*
;

ac_value = expr
         | ac_implied_do
         ;

(* R470 : C497 *)
ac_implied_do = lparen ac_value_list comma ac_implied_do_control rparen
              ;

(* R471 *)
ac_implied_do_control = ac_do_variable equal scalar_int_expr comma scalar_int_expr [ comma scalar_int_expr ]
                      ;

(* R472 : C493 *)
ac_do_variable = scalar_int_variable
               ;

(* **************************************************************************
 *
 * section 5
 *
 * ************************************************************************** *)
(* R501 : C507_C519 C522 C523 C526_C530 C532 C533 C535 C536 *)
type_declaration_stmt = declaration_type_spec [ { comma attr_spec }* coloncolon ] entity_decl_list eos
                      ;
(* R502 : C501 C502 C503 *)
declaration_type_spec = intrinsic_type_spec
                      | ( type_keyword lparen derived_type_spec rparen )
                      | ( class_keyword lparen derived_type_spec rparen )
                      | ( class_keyword lparen asterisk rparen )
                      ;

(* R503 : C531 C534 C547 *)
attr_spec = access_spec
          | allocatable_keyword
          | asynchronous_keyword
          | ( dimension_keyword lparen array_spec rparen )
          | external_keyword
          | ( intent_keyword lparen intent_spec rparen )
          | intrinsic_keyword
          | language_binding_spec
          | optional_keyword
          | parameter_keyword
          | pointer_keyword
          | protected_keyword
          | save_keyword
          | target_keyword
          | value_keyword
          | volatile_keyword
          ;

(* R504 : C504 C520 C521 C524 C525 *)
entity_name_list = entity_name { comma entity_name }*
;

entity_name = name
;

entity_decl_list = entity_decl { comma entity_decl }*
;

entity_decl = ( object_name [ lparen array_spec rparen ] [ asterisk char_length ] [ initialization ] )
            | ( function_name [ asterisk char_length ] )
            ;

(* R505 : C505 *)
object_name_list = object_name { comma object_name }*
;

object_name = name
            ;

(* R506 *)
initialization = ( equal initialization_expr )
               | ( arrow null_init )
               ;
(* R507 : C506 *)
null_init = function_reference
          ;


(* R508 : C539 *)
access_spec = public_keyword | private_keyword
            ;

(* R509 : C540 *)
language_binding_spec = bind_keyword lparen c_keyword [ comma name_keyword equal scalar_char_initialization_expr ] rparen
                      ;

(* R510 : C541 *)
array_spec = explicit_shape_spec_list
           | assumed_shape_spec_list
           | deferred_shape_spec_list
           | assumed_size_spec
           ;

(* R511 : C542 *)
explicit_shape_spec_list = explicit_shape_spec { comma explicit_shape_spec }*
;

explicit_shape_spec = [ lower_bound colon ] upper_bound
                    ;

(* R512 *)
lower_bound = specification_expr
            ;

(* R513 *)
upper_bound = specification_expr
            ;

(* R514 *)
assumed_shape_spec_list = assumed_shape_spec { comma assumed_shape_spec }*
;

assumed_shape_spec = [ lower_bound ] colon
                   ;

(* R515 *)
deferred_shape_spec_list = deferred_shape_spec { comma deferred_shape_spec }*
;

deferred_shape_spec = colon
                    ;

(* R516 *)
assumed_size_spec = [ explicit_shape_spec_list comma ] [lower_bound colon ] asterisk
                  ;

(* R517 : C545 C546 *)
intent_spec = in_keyword | out_keyword | in_out_keyword
            ;

(* R518 : C548 *)
access_stmt = access_spec [ [ coloncolon ] access_id_list ] eos
            ;
(* R519 : C549 *)
access_id_list = access_id { comma access_id }*
;

access_id = use_name
          | generic_spec
          ;

(* R520 *)
allocatable_stmt = allocatable_keyword [ coloncolon ] object_name [ lparen deferred_shape_spec_list rparen ] { comma object_name [ lparen deferred_shape_spec_list rparen ] }* eos
                 ;

(* R521 *)
asynchronous_stmt = asynchronous_keyword [ coloncolon ] object_name_list eos
                  ;

(* R522 : C550 C551 C552 *)
bind_stmt = language_binding_spec [ coloncolon ] bind_entity_list eos
          ;

(* R523 *)
bind_entity_list = bind_entity { comma bind_entity }*
;

bind_entity = entity_name
            | forwardslash common_block_name forwardslash
            ;

(* R524 *)
data_stmt = data_keyword data_stmt_set { [ comma ] data_stmt_set }*
          ;

(* R525 *)
data_stmt_set_list = data_stmt_set { comma data_stmt_set }*
;

data_stmt_set = data_stmt_object_list forwardslash data_stmt_value_list forwardslash
              ;

(* R526 : C553 C554 C555 *)
data_stmt_object_list = data_stmt_object { comma data_stmt_object }*
;

data_stmt_object = variable
                 | data_implied_do
                 ;
(* R527 : C557 *)
data_implied_do = lparen data_i_do_object_list comma data_i_do_variable equal scalar_int_expr comma scalar_int_expr [ comma scalar_int_expr ] rparen
                ;

(* R528 : C558 C559 C560 C561 *)
data_i_do_object_list = data_i_do_object { comma data_i_do_object }*
;

data_i_do_object = array_element
                 | scalar_structure_component
                 | data_implied_do
                 ;

(* R529 : C556 *)
data_i_do_variable = scalar_int_variable
                   ;


(* R530 *)
data_stmt_value_list = data_stmt_value { comma data_stmt_value }*
;

data_stmt_value = [ data_stmt_repeat asterisk ] data_stmt_constant
                ;

(* R531 : C562 *)
data_stmt_repeat = scalar_int_constant
                 | scalar_int_constant_subobject
                 ;


(* R532 : C563 C564 *)
data_stmt_constant = scalar_constant
                   | scalar_constant_subobject
                   | signed_int_literal_constant
                   | signed_real_literal_constant
                   | null_init
                   | structure_constructor
                   ;

(* R533 : C565 *)
scalar_int_constant_subobject = int_constant_subobject
;

int_constant_subobject = constant_subobject
                       ;

(* R534 : C566 C567 *)
scalar_constant_subobject = constant_subobject
;

constant_subobject = designator
                   ;

(* R535 *)
dimension_stmt = dimension_keyword [ coloncolon ] array_name lparen array_spec rparen { comma array_name lparen array_spec rparen }*
               ;

array_name = name
;

(* R536 *)
intent_stmt = intent_keyword lparen intent_spec rparen [ coloncolon ] dummy_arg_name_list
            ;

(* R537 *)
optional_stmt = optional_keyword [ coloncolon ] dummy_arg_name_list eos
              ;

(* R538 *)
parameter_stmt = parameter_keyword lparen named_constant_def_list rparen eos
               ;

(* R539 *)
named_constant_def_list = named_constant_def { comma named_constant_def }*
;

named_constant_def = named_constant equal initialization_expr
                   ;

(* R540 *)
pointer_stmt = pointer_keyword [ coloncolon ] pointer_decl_list eos
             ;

(* R541 : C568 *)
pointer_decl_list = pointer_decl { comma pointer_decl }*
;

pointer_decl = ( object_name [ lparen deferred_shape_spec_list rparen ] )
             | proc_entity_name
             ;

proc_entity_name = name
;

(* R542 *)
protected_stmt = protected_keyword [ coloncolon ] entity_name_list eos
               ;

(* R543 : C570 *)
save_stmt = save_keyword [ [ coloncolon ] saved_entity_list ] eos
          ;

(* R544 *)
saved_entity_list = saved_entity { comma saved_entity }*
;

saved_entity = object_name
             | proc_pointer_name
             | ( forwardslash common_block_name forwardslash )
             ;

(* R545 : C569 *)
proc_pointer_name = name
                  ;

(* R546 *)
target_stmt = target_keyword [ coloncolon ] object_name [ lparen array_spec rparen ] { comma object_name [ lparen array_spec rparen ] }* eos
            ;

(* R547 *)
value_stmt = value_keyword [ coloncolon ] dummy_arg_name_list eos
           ;

(* R548 *)
volatile_stmt =  volatile_keyword [ coloncolon ] object_name_list eos
              ;

(* R549 : C571 *)
implicit_stmt = (
                  (implicit_keyword implicit_spec_list)
                  | (implicit_keyword none_keyword)
                ) eos
              ;

(* R550 *)
implicit_spec_list = implicit_spec { comma implicit_spec }*
;

implicit_spec = declaration_type_spec lparen letter_spec_list rparen
              ;

(* R551 : C572 *)
letter_spec_list = letter_spec { comma letter_spec }*
                 ;

letter_spec = letter [ "â€“" letter ]
            ;

(* R552 : C573 C575 *)
namelist_stmt = namelist_keyword forwardslash namelist_group_name forwardslash namelist_group_object_list { [ comma ] forwardslash namelist_group_name forwardslash namelist_group_object_list }* eos
              ;

(* R553 : C574 *)
namelist_group_object_list = namelist_group_object { comma namelist_group_object }*
                           ;

namelist_group_object = variable_name
                      ;

namelist_group_name = name
;

(* R554 *)
equivalence_stmt = equivalence_keyword equivalence_set_list eos
                 ;

(* R555 : C580_C580 *)
equivalence_set_list = equivalence_set { comma equivalence_set }*
                     ;

equivalence_set = lparen equivalence_object comma equivalence_object_list rparen
                ;

(* R556 : C576_C579 C584_C586 *)
equivalence_object_list = equivalence_object { comma equivalence_object }*
                        ;

equivalence_object = variable_name
                   | array_element
                   | substring
                   ;

(* R557 *)
common_stmt = common_keyword [ forwardslash [ common_block_name ] forwardslash ] common_block_object_list { [ comma ] forwardslash [ common_block_name ] forwardslash common_block_object_list }* eos
            ;

common_block_name = name
                  ;

(* R558 : C587_C590 *)
common_block_object_list = common_block_object { comma common_block_object }*
                         ;

common_block_object = ( variable_name [ lparen explicit_shape_spec_list rparen ] )
                    | proc_pointer_name
                    ;

(* **************************************************************************
 *
 * section 6
 *
 * ************************************************************************** *)

(* R601 : C601 *)
scalar_variable = variable
                ;

variable = designator
         ;

(* R602 : C602 *)
variable_name = name
              ;

(* R603 *)
designator = object_name
           | array_element
           | array_section
           | structure_component
           | substring
           ;

(* R604 : C603 *)
scalar_logical_variable = logical_variable
                 ;

logical_variable = variable
                 ;

(* R605 : C604 - removed by F03/0114 corrigenda *)
(* scalar_default_logical_variable = default_logical_variable ;
default_logical_variable = variable ; *)

(* R606 : C605 *)
char_variable = variable
              ;

(* R607 : C606 *)
scalar_default_char_variable = default_char_variable
;

default_char_variable = variable
                      ;

(* R608 : C607 *)
scalar_int_variable = int_variable
;

int_variable = variable
             ;

(* R609 *)
substring = parent_string lparen substring_range rparen
          ;

(* R610 : C608 *)
scalar_variable_name = name
                     ;

parent_string = scalar_variable_name
              | array_element
              | scalar_structure_component
              | scalar_constant
              ;

(* R611 *)
substring_range = [ scalar_int_expr ] colon [ scalar_int_expr ]
                ;

(* R612 : C609 C610 C611 C612 C614 *)
data_ref = part_ref { percent part_ref }*
         ;

(* R613 : C613 *)
part_ref = part_name [ lparen section_subscript_list rparen ]
         ;

part_name = name
          ;

(* R614 : C615 *)
scalar_structure_component = structure_component
;

structure_component = data_ref
                    ;

(* R615 : C616 *)
type_param_inquiry = designator percent type_param_name
                   ;

(* R616 : C617 *)
array_element = data_ref
              ;

(* R617 : C618 C619 *)
array_section = data_ref [ lparen substring_range rparen ]
              ;


(* R618 *)
subscript = scalar_int_expr
          ;

(* R619 *)
section_subscript_list = section_subscript { comma section_subscript }*
                       ;

section_subscript = subscript
                  | subscript_triplet
                  | vector_subscript
                  ;

(* R620 : C621 *)
subscript_triplet = [ subscript ] colon [ subscript ] [ colon stride ]
                  ;

(* R621 *)
stride = scalar_int_expr
       ;

(* R622 : C620 *)
vector_subscript = int_expr
                 ;

(* R623 : C623 C624 C625 C626 C627 C631 C632 C633 *)
allocate_stmt = allocate_keyword lparen [ type_spec coloncolon ] allocation_list [comma alloc_opt_list ] rparen
              ;

(* R624 : C630 C629 C628 *)
stat_opt = stat_keyword equal stat_variable
         ;

errmsg_opt = errmsg_keyword equal errmsg_variable
           ;

alloc_opt_list = alloc_opt { comma alloc_opt }*
;

alloc_opt = stat_opt
          | errmsg_opt
          | (source_keyword equal source_expr)
          ;

(* R625 *)
stat_variable = scalar_int_variable
              ;

(* R626 *)
errmsg_variable = scalar_default_char_variable
                ;

(* R627 *)
source_expr = expr
            ;

(* R628 *)
allocation_list = allocation { comma allocation }*
;

allocation = allocate_object [ lparen allocate_shape_spec_list rparen ]
           ;

(* R629 : C622 *)
allocate_object_list = allocate_object { comma allocate_object }*
;

allocate_object = variable_name
                | structure_component
                ;

(* R630 *)
allocate_shape_spec_list = allocate_shape_spec { comma allocate_shape_spec }*
                         ;

allocate_shape_spec = [ lower_bound_expr colon ] upper_bound_expr
                    ;

(* R631 *)
lower_bound_expr = scalar_int_expr
                 ;

(* R632 *)
upper_bound_expr = scalar_int_expr
                 ;


(* R633 *)
nullify_stmt = nullify_keyword lparen pointer_object_list rparen
             ;
(* R634 : C634 *)
pointer_object_list = pointer_object { comma pointer_object }*
;

pointer_object = variable_name
               | structure_component
               | proc_pointer_name
               ;

(* R635 : C635 *)
deallocate_stmt = deallocate_keyword lparen allocate_object_list [ comma dealloc_opt_list ] rparen
                ;


(* R636 : C636 *)
dealloc_opt_list = dealloc_opt { comma dealloc_opt }*
;

dealloc_opt = stat_opt
            | errmsg_opt
            ;

(* **************************************************************************
 *
 * section 7
 *
 * ************************************************************************** *)
(* R701 : C701 C702 *)
primary = function_reference
        | designator
        | array_constructor
        | structure_constructor
        | constant
        | type_param_inquiry
        | type_param_name
        | (lparen expr rparen)
        ;

(* R702 *)
level_1_expr = [ defined_unary_op ] primary
             ;

(* R703 : C703 *)
defined_unary_op = "." { letter }+ "."
                 ;

(* R704 : *)
mult_operand = level_1_expr [ power_op mult_operand ]
             ;

(* NOTE(bja, 2015-01) R705, R706, R710 use left recursion, which doesn't work
with peg parsers. we need to convert it to some combination of
iteration/right recursion.
FIXME(bja, 2015-01) Pure right recursion will not get the
operator precidence correct! see
http://www.dalnefre.com/wp/2011/05/parsing-expression-grammars-part-4/
*)

(* R705 : FIXME(bja, 2015-01) Pure right recursion will not get the
operator precidence correct! *)
add_operand = mult_operand [ mult_op add_operand ] ;

(* R706 : FIXME(bja, 2015-01) Pure right recursion will not get the
operator precidence correct! *)
level_2_expr = add_operand [ add_op [ level_2_expr ] ]
             ;

(* R707 *)
power_op = "**"
         ;

(* R708 *)
mult_op = asterisk
        | forwardslash
        ;

(* R709 *)
add_op = plus
       | minus
       ;

(* R710 : FIXME(bja, 2015-01) Pure right recursion will not get the
operator precidence correct! *)
level_3_expr = level_2_expr [ concat_op level_3_expr ]
             ;

(* R711 *)
concat_op = "//"
          ;

(* R712 : *)
level_4_expr = [ level_3_expr rel_op ] level_3_expr
             ;

(* R713 *)
rel_op = ".eq." | "=="
       | ".ne." | "/="
       | ".lt." | ("<" !"=")
       | ".le." | "<="
       | ".gt." | (">" !"=")
       | ".ge." | ">="
       ;

(* R714 : *)
and_operand = [ not_op ] level_4_expr
            ;

(* R715 : FIXME(bja, 201502) Pure right recursion will not get the
operator precidence correct! *)
(* or_operand = [ or_operand and_op ] and_operand *)
or_operand = and_operand [ and_op or_operand ]
           ;

(* R716 : FIXME(bja, 201502) Pure right recursion will not get the
operator precidence correct! *)
(* equiv_operand = [ equiv_operand or_op ] or_operand *)
equiv_operand = or_operand [ or_op equiv_operand ]
              ;

(* R717 : FIXME(bja, 201502) Pure right recursion will not get the
operator precidence correct! *)
(* level_5_expr = [ level_5_expr equiv_op ] equiv_operand *)
level_5_expr = equiv_operand [ equiv_op level_5_expr equiv_op ]
             ;


(* R718 *)
not_op = ".not."
       ;

(* R719 *)
and_op = ".and."
       ;

(* R720 *)
or_op = ".or."
      ;

(* R721 *)
equiv_op = ".eqv." | ".neqv."
         ;


(* R722 : *)
scalar_expr = expr
;

(* FIXME(bja, 201502) Pure right recursion will not get the
operator precidence correct! *)
(* expr = [ expr defined_binary_op ] level_5_expr *)
expr = level_5_expr [ defined_binary_op expr ]
     ;

(* R723 : C704 *)
defined_binary_op = "." { letter }+ "."
                  ;


(* R724 : C705 *)
scalar_logical_expr = logical_expr
;

logical_expr = expr
             ;

(* R725 : C706 *)
scalar_char_expr = char_expr
;

char_expr = expr
          ;

(* R726 : C707 *)
scalar_default_char_expr = default_char_expr
;

default_char_expr = expr
                  ;


(* R727 : C708 *)
scalar_int_expr = int_expr
;

int_expr = expr
         ;

(* R728 : C709 *)
scalar_numeric_expr = numeric_expr
;

numeric_expr = expr
             ;

(* R729 : C710 *)
specification_expr = scalar_int_expr
                   ;

(* R730 : C711 *)
initialization_expr = expr
                    ;

(* R731 : C712 *)
scalar_char_initialization_expr = char_initialization_expr
;

char_initialization_expr = char_expr
                         ;

(* R732 : C713 *)
scalar_int_initialization_expr = int_initialization_expr
;

int_initialization_expr = int_expr
                        ;

(* R733 : C714 *)
scalar_logical_initialization_expr = logical_initialization_expr
;

logical_initialization_expr = logical_expr
                            ;

(* R734 : C715 *)
assignment_stmt = variable equal expr
                ;

(* R735 : C716 C717 C718 C719 C720 *)
pointer_assignment_stmt = ( data_pointer_object [ lparen bounds_spec_list rparen ] arrow data_target )
                        | ( data_pointer_object lparen bounds_remapping_list rparen arrow data_target )
                        | ( proc_pointer_object arrow proc_target )
                        ;

(* R736 : C721 C722 *)
data_pointer_object = variable_name
                    | ( scalar_variable percent data_pointer_component_name )
                    ;

data_pointer_component_name = name
;

(* R737 : *)
bounds_spec_list = bounds_spec { comma bounds_spec }*
;

bounds_spec = lower_bound_expr colon
            ;

(* R738 : *)
bounds_remapping_list = bounds_remapping { comma bounds_remapping }*
;

bounds_remapping = lower_bound_expr colon upper_bound_expr
                 ;

(* R739 : C723 C724 *)
data_target = variable
            | expr
            ;

(* R740 : *)
proc_pointer_object = proc_pointer_name
                    | proc_component_ref
                    ;

(* R741 : C725 *)
proc_component_ref = scalar_variable percent procedure_component_name
                   ;

procedure_component_name = name
;

(* R742 : C726 C727 C728 *)
proc_target = expr
            | procedure_name
            | proc_component_ref
            ;



(* R743 : *)
where_stmt = where_keyword lparen mask_expr rparen where_assignment_stmt
           ;

(* R744 : C730 *)
where_construct = where_construct_stmt
                    { where_body_construct }*
                    { masked_elsewhere_stmt { where_body_construct }* }*
                    [ elsewhere_stmt { where_body_construct }* ]
                end_where_stmt
                ;

(* R745 : *)
where_construct_name = name
                     ;

where_construct_stmt = [ where_construct_name colon ] where_keyword lparen mask_expr rparen eos
                     ;

(* R746 : C731 *)
where_body_construct = where_assignment_stmt
                     | where_stmt
                     | where_construct
                     ;

(* R747 : C729 *)
where_assignment_stmt = assignment_stmt
                      ;

(* R748 : *)
scalar_mask_expr = mask_expr
;

mask_expr = logical_expr
          ;

(* R749 : *)
masked_elsewhere_stmt = else_where_keyword lparen mask_expr rparen [ where_construct_name ]
                      ;

(* R750 : *)
elsewhere_stmt = else_where_keyword [where_construct_name ]
               ;

(* R751 : *)
end_where_stmt = end_where_keyword [where_construct_name ]
               ;

(* R752 : *)
forall_construct = forall_construct_stmt
                     { forall_body_construct }*
                 end_forall_stmt
                 ;

(* R753 : *)
forall_construct_name = name
;

forall_construct_stmt = [ forall_construct_name colon ] forall_keyword forall_header
                      ;

(* R754 : C733 C734 *)
forall_header = lparen forall_triplet_spec_list [comma scalar_mask_expr] rparen
              ;

(* R755 : C735 C736 *)
forall_triplet_spec_list = forall_triplet_spec { comma forall_triplet_spec }*
;

index_name = name
;

forall_triplet_spec = index_name equal subscript colon subscript [ colon stride ]
                    ;

(* R756 : C737 C738 C739 *)
forall_body_construct = forall_assignment_stmt
                      | where_stmt
                      | where_construct
                      | forall_construct
                      | forall_stmt
                      ;

(* R757 : *)
forall_assignment_stmt = assignment_stmt
                       | pointer_assignment_stmt
                       ;

(* R758 : C732 *)
end_forall_stmt = end_forall_keyword [forall_construct_name ]

                ;


(* R759 : *)
forall_stmt = forall_keyword forall_header forall_assignment_stmt
            ;


(* **************************************************************************
 *
 * section 8
 *
 * ************************************************************************** *)
(* R801 : *)
block = { execution_part_construct }*
      ;

(* R802 : C801 *)
if_construct_name = name
;

if_construct = if_then_stmt
                 block
             { else_if_stmt
                 block }*
             [ else_stmt
                 block ]
             end_if_stmt
             ;

(* R803 : *)
if_then_stmt = [ if_construct_name colon ] if_keyword lparen scalar_logical_expr rparen then_keyword eos
             ;

(* R804 : *)
else_if_stmt = else_if_keyword lparen scalar_logical_expr rparen then_keyword [ if_construct_name ] eos
             ;

(* R805 : *)
else_stmt = else_keyword [ if_construct_name ] eos
          ;

(* R806 : *)
end_if_stmt = end_if_keyword [ if_construct_name ] eos
            ;


(* R807 : C802 *)
if_stmt = if_keyword lparen scalar_logical_expr rparen action_stmt
        ;


(* R808 : C803 C804 C805 C806 C807 *)
case_construct_name = name
;

case_construct = select_case_stmt { case_stmt block }* end_select_stmt
               ;

(* R809 : *)
select_case_stmt =  [ case_construct_name colon ] select_case_keyword lparen case_expr rparen
                 ;

(* R810 : *)
case_stmt = case_keyword case_selector [ case_construct_name ]
          ;

(* R811 : *)
end_select_stmt = end_select_keyword [ case_construct_name ]
                ;


(* R812 : *)
case_expr = scalar_int_expr
          | scalar_char_expr
          | scalar_logical_expr
          ;

(* R813 : *)
case_selector = ( lparen case_value_range_list rparen )
              | default_keyword
              ;

(* R814 : *)
case_value_range_list = case_value_range { comma case_value_range }*
;

case_value_range = case_value
                 | ( case_value colon )
                 | ( colon case_value )
                 | ( case_value colon case_value )
                 ;

(* R815 : *)
case_value = scalar_int_initialization_expr
           | scalar_char_initialization_expr
           | scalar_logical_initialization_expr
           ;


(* R816 : *)
associate_construct_name = name
;

associate_construct = associate_stmt
                        block
                    end_associate_stmt
                    ;

(* R817 : *)
associate_stmt = [ associate_construct_name colon ] associate_keyword lparen association_list rparen
               ;

(* R818 : C808 C809 *)
associate_name = name
               ;

association_list = association { comma association }*
;

association = associate_name arrow selector
            ;

(* R819 : *)
selector = expr
         | variable
         ;

(* R820 : C810 *)
end_associate_stmt = end_associate_keyword [ associate_construct_name ]
                   ;


(* R821 : *)
select_type_construct = select_type_stmt
                          { type_guard_stmt block }*
                      end_select_type_stmt
                      ;

(* R822 : C*11 C812 C813 *)
select_construct_name = name
;

select_type_stmt = [ select_construct_name colon ] select_type_keyword lparen [ associate_name arrow ] selector rparen
                 ;

(* R823 :  C814 C815 C816 C817 C818 *)
type_guard_stmt = ( type_keyword is_keyword lparen type_spec rparen [ select_construct_name ] )
                | ( class_keyword is_keyword lparen derived_type_spec rparen [ select_construct_name ] )
                | ( class_keyword default_keyword [ select_construct_name ] )
                ;

(* R824 : C819 *)
end_select_type_stmt = end_select_keyword [ select_construct_name ]
                     ;


(* R825 : *)
do_construct_name = name
;

do_construct = block_do_construct
             | nonblock_do_construct
             ;

(* R826 : C821 C822 C823 *)
block_do_construct = do_stmt
                       do_block
                   end_do
                   ;

(* R827 : *)
do_stmt = label_do_stmt
        | nonlabel_do_stmt
        ;

(* R828 : *)
label_do_stmt = [ do_construct_name colon ] do_keyword label [ loop_control ]
              ;

(* R829 : *)
nonlabel_do_stmt =  [ do_construct_name colon ] do_keyword [ loop_control ]
                 ;

(* R830 : *)
loop_control = ( [ comma ] do_variable equal scalar_int_expr comma scalar_int_expr [ comma scalar_int_expr ] )
             | ( [ comma ] while_keyword lparen scalar_logical_expr rparen )
             ;

(* R831 : C820 *)
do_variable = scalar_int_variable
            ;


(* R832 : *)
do_block = block
         ;

(* R833 : *)
end_do = end_do_stmt
       | continue_stmt
       ;

(* R834 : *)
end_do_stmt = end_do_keyword [ do_construct_name ]
            ;


(* R835 : C825 *)
nonblock_do_construct = action_term_do_construct
                      | outer_shared_do_construct
                      ;

(* R836 : *)
action_term_do_construct = label_do_stmt
                             do_body
                             do_term_action_stmt
                         ;

(* R837 : *)
do_body = { execution_part_construct }*
        ;

(* R838 : C824 *)
do_term_action_stmt = action_stmt
                    ;

(* R839 : *)
outer_shared_do_construct = label_do_stmt
                              do_body
                              shared_term_do_construct
                          ;

(* R840 : C827 *)
shared_term_do_construct = outer_shared_do_construct
                         | inner_shared_do_construct
                         ;

(* R841 : *)
inner_shared_do_construct = label_do_stmt
                              do_body
                              do_term_shared_stmt
                          ;

(* R842 : C826 *)
do_term_shared_stmt = action_stmt
                    ;

(* R843 : C828 *)
cycle_stmt = cycle_keyword [ do_construct_name ]
           ;

(* R844 : *)
exit_stmt = exit_keyword [ do_construct_name ]
          ;

(* R845 : C830 *)
goto_stmt = go_to_keyword label
          ;


(* R846 : C831 *)
computed_goto_stmt = go_to_keyword lparen label_list rparen [ comma ] scalar_int_expr
                   ;

(* R847 : C832 C833 *)
arithmetic_if_stmt = if_keyword lparen scalar_numeric_expr rparen label comma label comma label
                   ;

(* R848 : *)
continue_stmt = continue_keyword
              ;

(* R849 : *)
stop_stmt = stop_keyword [ stop_code ]
          ;

(* R850 : C834 *)
stop_code = scalar_char_constant
          | digit [ digit [ digit [ digit [ digit ]]]]
          ;


(* **************************************************************************
 *
 * section 9
 *
 * ************************************************************************** *)
(* R901 : *)
io_unit = file_unit_number
        | asterisk
        | internal_file_variable
        ;

(* R902 : *)
file_unit_number = scalar_int_expr
                 ;

(* R903 : C901 C902 *)
internal_file_variable = char_variable
                       ;


(* R904 : *)
open_stmt = open_keyword lparen connect_spec_list rparen
          ;

(* R905 : C903 C904 C905 *)
connect_spec_list = connect_spec { comma connect_spec }*
                  ;

connect_spec = ( [ unit_keyword equal ] file_unit_number )
             | ( access_keyword equal scalar_default_char_expr )
             | ( action_keyword equal scalar_default_char_expr )
             | ( asynchronous_keyword equal scalar_default_char_expr )
             | ( blank_keyword equal scalar_default_char_expr )
             | ( decimal_keyword equal scalar_default_char_expr )
             | ( delim_keyword equal scalar_default_char_expr )
             | ( encoding_keyword equal scalar_default_char_expr )
             | ( err_keyword equal label )
             | ( file_keyword equal file_name_expr )
             | ( form_keyword equal scalar_default_char_expr )
             | ( iomsg_keyword equal iomsg_variable )
             | ( iostat_keyword equal scalar_int_variable )
             | ( pad_keyword equal scalar_default_char_expr )
             | ( position_keyword equal scalar_default_char_expr )
             | ( recl_keyword equal scalar_int_expr )
             | ( round_keyword equal scalar_default_char_expr )
             | ( sign_keyword equal scalar_default_char_expr )
             | ( status_keyword equal scalar_default_char_expr )
             ;

(* R906 : *)
file_name_expr = scalar_default_char_expr
               ;

(* R907 : *)
iomsg_variable = scalar_default_char_variable
               ;

(* R908 : *)
close_stmt = close_keyword lparen close_spec_list rparen
           ;

(* R909 : C906 C907 C908 *)
close_spec_list =  close_spec { comma close_spec }*
                ;

close_spec =  ( [ unit_keyword equal ] file_unit_number )
           | ( iostat_keyword equal scalar_int_variable )
           | ( iomsg_keyword equal iomsg_variable )
           | ( err_keyword equal label )
           | ( status_keyword equal scalar_default_char_expr )
           ;

(* R910 : *)
read_stmt = ( read_keyword lparen io_control_spec_list rparen [ input_item_list ] )
          | ( read_keyword format [ comma input_item_list ] )
          ;

(* R911 : *)
write_stmt = write_keyword lparen io_control_spec_list rparen [ output_item_list ]
           ;

(* R912 : *)
print_stmt = print_keyword format [ comma output_item_list ]
           ;

(* R913 : C909 C910 C911 C912 C913 C914 C915 C916 C917 C918 C919 C920 C921 C922 C923 C924 C925 C926 C927 C928 C929  *)
io_control_spec_list =  io_control_spec { comma io_control_spec }*
                     ;

io_control_spec = ( [ unit_keyword equal ] io_unit )
                | ( [ fmt_keyword equal ]format )
                | ( [ nml_keyword equal ] namelist_group_name )
                | ( advance_keyword equal scalar_default_char_expr )
                | ( asynchronous_keyword equal scalar_char_initialization_expr )
                | ( blank_keyword equal scalar_default_char_expr )
                | ( decimal_keyword equal scalar_default_char_expr )
                | ( delim_keyword equal scalar_default_char_expr )
                | ( end_keyword equal label )
                | ( eor_keyword equal label )
                | ( err_keyword equal label )
                | ( id_keyword equal id_variable )
                | ( iomsg_keyword equal iomsg_variable )
                | ( iostat_keyword equal scalar_int_variable )
                | ( pad_keyword equal scalar_default_char_expr )
                | ( pos_keyword equal scalar_int_expr )
                | ( rec_keyword equal scalar_int_expr )
                | ( round_keyword equal scalar_default_char_expr )
                | ( sign_keyword equal scalar_default_char_expr )
                | ( size_keyword equal scalar_int_variable )
                ;

(* R913a: C908a *)
id_variable = scalar_int_variable
            ;

(* R914 : C930 *)
format = default_char_expr
       | label
       | asterisk
       ;


(* R915 : C931 C932 *)
input_item_list =  input_item { comma input_item }*
                ;

input_item   = variable
             | io_implied_do
             ;

(* R916 : C935 *)
output_item_list =  output_item { comma output_item }*
                 ;

output_item = expr
            | io_implied_do
            ;

(* R917 : *)
io_implied_do = lparen io_implied_do_object_list comma io_implied_do_control rparen
              ;

(* R918 : C934 *)
io_implied_do_object_list =  io_implied_do_object { comma io_implied_do_object }*
                          ;

io_implied_do_object = input_item
                     | output_item
                     ;

(* R919 : C933 *)
io_implied_do_control = do_variable equal scalar_int_expr comma scalar_int_expr [ comma scalar_int_expr ]
                      ;

(* R920 : C936 C937 *)
dtv_type_spec = ( type_keyword lparen derived_type_spec rparen )
              | ( class_keyword lparen derived_type_spec rparen )
              ;


(* R921 : *)
wait_stmt = wait_keyword lparen wait_spec_list rparen
          ;

(* R922 : C938 C939 C940 *)
wait_spec_list =  wait_spec { comma wait_spec }*
               ;

wait_spec = ( [ unit_keyword equal ] file_unit_number )
          | ( end_keyword equal label )
          | ( eor_keyword equal label )
          | ( err_keyword equal label )
          | ( id_keyword equal scalar_int_variable )
          | ( iomsg_keyword equal iomsg_variable )
          | ( iostat_keyword equal scalar_int_variable )
          ;

(* R923 : *)
backspace_stmt = ( backspace_keyword file_unit_number )
               | ( backspace_keyword lparen position_spec_list rparen )
               ;

(* R924 : *)
endfile_stmt = ( end_file_keyword file_unit_number )
             | ( end_file_keyword lparen position_spec_list rparen )
             ;

(* R925 : *)
rewind_stmt = ( rewind_keyword file_unit_number )
            | ( rewind_keyword lparen position_spec_list rparen )
            ;


(* R926 : C941 C942 C943 *)
position_spec_list =  position_spec { comma position_spec }*
                   ;

position_spec =  ( [ unit_keyword equal ] file_unit_number )
              | ( iomsg_keyword equal iomsg_variable )
              | ( iostat_keyword equal scalar_int_variable )
              | ( err_keyword equal label )
              ;

(* R927 : *)
flush_stmt = ( flush_keyword file_unit_number )
            | ( flush_keyword lparen flush_spec_list rparen )
            ;


(* R928 : C944 C945 C946 *)
flush_spec_list =  flush_spec { comma flush_spec }*
                   ;

flush_spec =  ( [ unit_keyword equal ] file_unit_number )
              | ( iomsg_keyword equal iomsg_variable )
              | ( iostat_keyword equal scalar_int_variable )
              | ( err_keyword equal label )
              ;

(* R929 : *)
inquire_stmt = ( inquire_keyword lparen inquire_spec_list rparen )
             | ( inquire_keyword lparen iolength_keyword equal scalar_int_variable rparen output_item_list )
             ;

(* R930 : C947 C948 C949 C950 *)
inquire_spec_list =  inquire_spec { comma inquire_spec }*
                  ;

inquire_spec = ( [ unit_keyword equal ] file_unit_number )
             | ( file_keyword equal file_name_expr )
             | ( access_keyword equal scalar_default_char_variable )
             | ( action_keyword equal scalar_default_char_variable )
             | ( asynchronous_keyword equal scalar_default_char_variable )
             | ( blank_keyword equal scalar_default_char_variable )
             | ( decimal_keyword equal scalar_default_char_variable )
             | ( delim_keyword equal scalar_default_char_variable )
             | ( direct_keyword equal scalar_default_char_variable )
             | ( encoding_keyword equal scalar_default_char_variable )
             | ( err_keyword equal label )
             | ( exist_keyword equal scalar_logical_variable )
             | ( form_keyword equal scalar_default_char_variable )
             | ( formatted_keyword equal scalar_default_char_variable )
             | ( id_keyword equal scalar_int_variable )
             | ( iomsg_keyword equal iomsg_variable )
             | ( iostat_keyword equal scalar_int_variable )
             | ( name_keyword equal scalar_default_char_variable )
             | ( named_keyword equal scalar_logical_variable )
             | ( nextrec_keyword equal scalar_int_variable )
             | ( number_keyword equal scalar_int_variable )
             | ( opened_keyword equal scalar_logical_variable )
             | ( pad_keyword equal scalar_default_char_variable )
             | ( pending_keyword equal scalar_logical_variable )
             | ( pos_keyword equal scalar_int_variable )
             | ( position_keyword equal scalar_default_char_variable )
             | ( read_keyword equal scalar_default_char_variable )
             | ( readwrite_keyword equal scalar_default_char_variable )
             | ( recl_keyword equal scalar_int_variable )
             | ( round_keyword equal scalar_default_char_variable )
             | ( sequential_keyword equal scalar_default_char_variable )
             | ( sign_keyword equal scalar_default_char_variable )
             | ( size_keyword equal scalar_int_variable )
             | ( stream_keyword equal scalar_default_char_variable )
             | ( unformatted_keyword equal scalar_default_char_variable )
             | ( write_keyword equal scalar_default_char_variable )
             ;


(* **************************************************************************
 *
 * section 10
 *
 * ************************************************************************** *)

(* R1001 : C1001 *)
format_stmt = format_keyword format_specification eos
            ;

(* R1002 : C1002 *)
format_specification = lparen [ format_item_list ] rparen
                     ;

(* R1003 : *)
format_item_list =  format_item { comma format_item }*
                 ;

format_item = ( [ r ] data_edit_desc )
            | control_edit_desc
            | char_string_edit_desc
            | ( [ r ] lparen format_item_list rparen )
            ;

(* R1004 : C1003 C1004 *)
r = int_literal_constant
  ;

(* R1005 : C1007 C1008 *)
data_edit_desc = ( "I" w [ "." m ] )
               | ( "B" w [ "." m ] )
               | ( "O" w [ "." m ] )
               | ( "Z" w [ "." m ] )
               | ( "F" w "." d     )
               | ( "E" w "." d [ "E" e ] )
               | ( "EN" w "." d [ "E" e ] )
               | ( "ES" w "." d [ "E" e ] )
               | ( "G" w "." d [ "E" e ] )
               | ( "L" w )
               | ( "A" [ w ] )
               | ( "D" w "." d )
               | ( "DT" [ char_literal_constant ] [ lparen v_list rparen ] )
               ;

(* R1006 : C1006 *)
w = int_literal_constant
  ;

(* R1007 : *)
m = int_literal_constant
  ;

(* R1008 : *)
d = int_literal_constant
  ;

(* R1009 : C1005 *)
e = int_literal_constant
  ;

(* R1010 : *)
v_list =  v { comma v }*
       ;
v = signed_int_literal_constant
  ;

(* R1011 : *)
control_edit_desc = position_edit_desc
                  | ( [ r ] forwardslash )
                  | colon
                  | sign_edit_desc
                  | ( k "P" )
                  | blank_interp_edit_desc
                  | round_edit_desc
                  | decimal_edit_desc
                  ;

(* R1012 : C1009 *)
k = signed_int_literal_constant
  ;

(* R1013 : *)
position_edit_desc = ( "T" n )
                   | ( "TL" n )
                   | ( "TR" n )
                   | ( n "X" )
                   ;

(* R1014 : C1010 C1011 *)
n = int_literal_constant
  ;

(* R1015 : *)
sign_edit_desc = "SS"
               | "SP"
               | "S"
               ;

(* R1016 : *)
blank_interp_edit_desc = "BN"
                       | "BZ"
                       ;

(* R1017 : *)
round_edit_desc = "RU"
                | "RD"
                | "RZ"
                | "RN"
                | "RC"
                | "RP"
                ;

(* R1018 : *)
decimal_edit_desc = "DC"
                  | "DP"
                  ;

(* R1019 : C1012 *)
char_string_edit_desc = char_literal_constant
                      ;



(* **************************************************************************
 *
 * section 11
 *
 * ************************************************************************** *)

(* R1101 : C1101 C1102 C1103 *)
main_program = [ program_stmt ]
                  [ specification_part ]
                  [ execution_part ]
                  [ internal_subprogram_part ]
              end_program_stmt
              ;

(* R1102 *)
program_stmt = program_keyword program_name
             ;
program_name = name
             ;

(* R1103 *)
end_program_stmt = ( end_keyword )
                 | ( end_program_keyword [ program_name ] )
                 ;

(* R1104 : C1104 C1105 C1106 C1107 *)
module = module_stmt
            [ specification_part ]
            [ module_subprogram_part ]
        end_module_stmt
        ;

(* R1105 *)
module_stmt = module_keyword module_name eos
            ;

module_name = name
            ;

(* R1106 *)
end_module_stmt = ( end_keyword
                | ( end_module_keyword [ module_name ] ))
                eos
                ;

(* R1107 *)
module_subprogram_part = contains_stmt
                       { module_subprogram }+
                       ;

(* R1108 *)
module_subprogram = function_subprogram |
                  subroutine_subprogram
                  ;

(* R1109 : C1108 C1109 C1110 *)
use_stmt =
         ws_opt use_keyword [ [ comma module_nature ] coloncolon ] module_name [
             ( comma rename_list )
             | ( comma only_keyword colon [ only_list ] )
         ] eos
         ;

(* R1110 *)
module_nature = intrinsic_keyword
              | non_intrinsic_keyword
              ;

(* R1111 : C1111 *)
rename_list =  rename { comma rename }*
            ;

rename = ( local_name arrow use_name )
       | ( operator_keyword lparen local_defined_operator rparen arrow operator_keyword lparen use_defined_operator rparen )
       ;

use_name = name
         ;

local_name = name
           ;

(* R1112 : C1112 C1113 *)
only_list =  only { comma only }*
          ;

only = rename
     | only_use_name
     | generic_spec
     ;

(* R1113 : C1114 *)
only_use_name = use_name
              ;

(* R1114 *)
local_defined_operator = defined_unary_op
                       | defined_binary_op
                       ;

(* R1115 : C1115 *)
use_defined_operator = defined_unary_op
                     | defined_binary_op
                     ;

(* R1116 : C1116 C117 C1118 *)
block_data = block_data_stmt
                [ specification_part ]
            end_block_data_stmt
            ;

(* R1117 *)
block_data_stmt = block_data_keyword [ block_data_name ]
                ;

block_data_name = name
                ;

(* R1118 *)
end_block_data_stmt = end_keyword
                    | ( end_block_data_keyword [ block_data_name ] )
                    ;

(* **************************************************************************
 *
 * section 12
 *
 * ************************************************************************** *)

(* R1201 : C1201 C1202 *)
interface_block = interface_stmt
                    { interface_specification }*
                end_interface_stmt
                ;

(* R1202 : C1204 *)
interface_specification = interface_body
                        | procedure_stmt
                        ;

(* R1203 : C1203 *)
interface_stmt = ( interface_keyword [ generic_spec ] )
               | ( abstract_keyword interface_keyword )
               ;

(* R1204 *)
end_interface_stmt = ( end_keyword [ generic_spec ] )
                   | ( end_interface_keyword [ generic_spec ])
                   ;

(* R1205 : C1205 C1206 *)
interface_body = ( function_stmt [ specification_part ] end_function_stmt )
               | ( subroutine_stmt [ specification_part ] end_subroutine_stmt )
               ;

(* R1206 : C1207 C1208 C1209 *)
procedure_stmt =  [ module_keyword ] procedure_keyword procedure_name_list
               ;

(* R1207 *)
generic_spec = generic_name
             | ( operator_keyword lparen defined_operator rparen )
             | ( assignment_keyword  lparen equal rparen )
             | dtio_generic_spec
             ;

generic_name = name
             ;

(* R1208 *)
dtio_generic_spec = ( read_keyword lparen formatted_keyword rparen )
                  | ( read_keyword lparen unformatted_keyword rparen )
                  | ( write_keyword lparen formatted_keyword rparen )
                  | ( write_keyword lparen unformatted_keyword rparen )
                  ;

(* R1209 : C1210 C1211 *)
import_stmt = import_keyword [ coloncolon ] import_name_list
            ;

import_name_list = import_name { comma import_name }*
                 ;

import_name = name
            ;

(* R1210 *)
external_stmt = external_keyword [ coloncolon ] external_name_list
              ;

external_name_list = external_name { comma external_name }*
                 ;

external_name = name
            ;

(* R1211 : C1217 C1218 *)
procedure_declaration_stmt = procedure_keyword lparen [ proc_interface ] rparen
                           [ { comma proc_attr_spec }* coloncolon ] proc_decl_list
                           ;
(* R1212 *)
proc_interface = interface_name
               | declaration_type_spec
               ;

(* R1213 *)
proc_attr_spec = access_spec
               | proc_language_binding_spec
               | ( intent_keyword lparen intent_spec rparen )
               | optional_keyword
               | pointer_keyword
               | save_keyword
               ;

(* R1214 : C1216 *)
proc_decl_list = proc_decl { comma proc_decl }*
                 ;

procedure_entity_name = name
                      ;

proc_decl = procedure_entity_name [ arrow null_init ]
          ;

(* R1215 : C1212 C1223 *)
interface_name = name
               ;

(* R1216 : C1219 *)
intrinsic_stmt = intrinsic_keyword [ coloncolon ] intrinsic_procedure_name_list
               ;

(* R1217 : C1220 C1221 *)
function_reference = procedure_designator lparen [ actual_arg_spec_list ] rparen
                   ;

(* R1218 : C1222 *)
call_stmt = call_keyword procedure_designator [ lparen [ actual_arg_spec_list ] rparen ]
          ;

(* R1219 : C1223 C1224 *)
procedure_designator = procedure_name
                     | proc_component_ref
                     | ( data_ref percent binding_name )
                     ;

procedure_name_list =  procedure_name { comma procedure_name }*
                    ;

procedure_name = name
               ;

(* R1220 : C1225_C1227 *)
actual_arg_spec_list =  actual_arg_spec { comma actual_arg_spec }*
                     ;

actual_arg_spec = [ keyword equal ] actual_arg
                ;

(* R1221 : C1228_C1233 *)
actual_arg = expr
           | variable
           | procedure_name
           | proc_component_ref
           | alt_return_spec
           ;

(* R1222 *)
alt_return_spec = asterisk label
                ;

(* R1223 : C1244 C1245 *)
function_subprogram = function_stmt
                        [ specification_part ]
                        [ execution_part ]
                        [ internal_subprogram_part ]
                    end_function_stmt
                    ;

(* R1224 : C1234 C1235 *)
function_stmt = [ prefix ] function_keyword function_name
              lparen [ dummy_arg_name_list ] rparen [ suffix ] eos
              ;

function_name = name ws_opt
              ;

(* R1225 : C1236 C1237 C1238 *)
proc_language_binding_spec = language_binding_spec
                           ;

(* R1226 : C1239 *)
dummy_arg_name_list =  dummy_arg_name { comma dummy_arg_name }*
                    ;

dummy_arg_name = name ws_opt
               ;

(* R1227 : C1240 C1241 C1242 *)
prefix = { prefix_spec }+
       ;

(* R1228 *)
prefix_spec = declaration_type_spec
            | recursive_keyword
            | pure_keyword
            | elemental_keyword
            ;

(* R1229 *)
suffix = ( proc_language_binding_spec [ result_keyword lparen result_name rparen ] )
       | ( result_keyword lparen result_name rparen [ proc_language_binding_spec ] )
       ;

result_name = name
            ;

(* R1230 : C1243 C1246 *)
end_function_stmt =
                  (
                      ( end_function_keyword [ function_name ] )
                      | ( end_keyword [ function_name ] )
                  ) eos
                  ;

(* R1231 *)
subroutine_subprogram = subroutine_stmt
                          [ specification_part ]
                          [ execution_part ]
                          [ internal_subprogram_part ]
                      end_subroutine_stmt
                      ;
(* R1232 : C1247 *)
subroutine_stmt = [ prefix ] subroutine_keyword subroutine_name
                [ lparen [ dummy_arg_list ] rparen [ proc_language_binding_spec ] ]  eos
                ;

subroutine_name = name ws_opt
                ;

(* R1231 : C1249 C1250 *)
dummy_arg_list =  dummy_arg { comma dummy_arg }*
               ;

dummy_arg = dummy_arg_name
          | asterisk
          ;

(* R1234 : C1348 C1251 *)
end_subroutine_stmt =
                    (
                        ( end_subroutine_keyword [ subroutine_name ] )
                        | ( end_keyword [ subroutine_name ] )
                    ) eos
                    ;

(* R1235 : C1252_C1257 *)
entry_stmt = entry_keyword entry_name [ lparen [ dummy_arg_list ] rparen [ suffix ] ] eos
           ;

entry_name = name
           ;

(* R1236 : C1258 C1259 *)
return_stmt = return_keyword [ scalar_int_expr ]
            ;

(* R1237 *)
contains_stmt = contains_keyword eos
              ;

(* R1238 : C1261_C1265 *)
stmt_function_stmt = function_name lparen [ dummy_arg_name_list ] rparen equal scalar_expr
                   ;


(* **************************************************************************
 *
 * section 13
 *
 * ************************************************************************** *)
intrinsic_procedure_name_list =  intrinsic_procedure_name { comma intrinsic_procedure_name }*
                              ;

intrinsic_procedure_name = intrinsic_numeric_function_name
                         | intrinsic_mathematical_function_name
                         | intrinsic_character_function_name
                         | intrinsic_kind_function_name
                         | intrinsic_type_conversion_function_name
                         | intrinsic_numeric_inquiry_function_name
                         | intrinsic_array_inquiry_function_name
                         | intrinsic_other_inquiry_function_name
                         | intrinsic_bit_manipulation_function_name
                         | intrinsic_floating_point_function_name
                         | intrinsic_vector_matrix_function_name
                         | intrinsic_array_reduction_function_name
                         | intrinsic_array_construction_function_name
                         | intrinsic_array_location_function_name
                         | intrinsic_null_function_name
                         | intrinsic_allocation_transfer_function_name
                         | intrinsic_random_number_function_name
                         | intrinsic_system_environment_function_name
                         ;


intrinsic_numeric_function_name = ( "ABS" | "abs" )
                                | ( "AIMAG" | "aimag" )
                                | ( "AINT" | "aint" )
                                | ( "ANINT" | "anint" )
                                | ( "CEILING" | "ceiling" )
                                | ( "CMPLX" | "cmplx" )
                                | ( "CONJG" | "conjg" )
                                | ( "DBLE" | "dble" )
                                | ( "DIM" | "dim" )
                                | ( "DPROD" | "dprod" )
                                | ( "FLOOR" | "floor" )
                                | ( "INT" | "int" )
                                | ( "MAX" | "max" )
                                | ( "MIN" | "min" )
                                | ( "MOD" | "mod" )
                                | ( "MODULO" | "modulo" )
                                | ( "NINT" | "nint" )
                                | ( "REAL" | "real" )
                                | ( "SIGN" | "sign" )
                                ;

intrinsic_mathematical_function_name =  ( "ACOS" | "acos" )
                                     | ( "ASIN" | "asin" )
                                     | ( "ATAN" | "atan" )
                                     | ( "ATAN2" | "atan2" )
                                     | ( "COS" | "cos" )
                                     | ( "COSH" | "cosh" )
                                     | ( "EXP" | "exp" )
                                     | ( "LOG" | "log" )
                                     | ( "LOG10" | "log10" )
                                     | ( "SIN" | "sin" )
                                     | ( "SINH" | "sinh" )
                                     | ( "SQRT" | "sqrt" )
                                     | ( "TAN" | "tan" )
                                     | ( "TANH" | "tanh" )
                                     ;

intrinsic_character_function_name = ( "ACHAR" | "achar" )
                                  | ( "ADJUSTL" | "adjustl" )
                                  | ( "ADJUSTR" | "adjustr" )
                                  | ( "CHAR" | "char" )
                                  | ( "IACHAR" | "iachar" )
                                  | ( "ICHAR" | "ichar" )
                                  | ( "INDEX" | "index" )
                                  | ( "LEN_TRIM" | "len_trim" )
                                  | ( "LGE" | "lge" )
                                  | ( "LGT" | "lgt" )
                                  | ( "LLE" | "lle" )
                                  | ( "LLT" | "llt" )
                                  | ( "MAX" | "max" )
                                  | ( "MIN" | "min" )
                                  | ( "REPEAT" | "repeat" )
                                  | ( "SCAN" | "scan" )
                                  | ( "TRIM" | "trim" )
                                  | ( "VERIFY" | "verify" )
                                  ;

intrinsic_kind_function_name = ( "KIND" | "kind" )
                             | ( "SELECTED_CHAR_KIND" | "selected_char_kind" )
                             | ( "SELECTED_INT_KIND" | "selected_int_kind" )
                             | ( "SELECTED_REAL_KIND" | "selected_real_kind" )
                             ;


intrinsic_type_conversion_function_name = ( "LOGICAL" | "logical" )
                                        | ( "TRANSFER" | "transfer" )
                                        ;

intrinsic_numeric_inquiry_function_name = ( "DIGITS" | "digits" )
                                        | ( "EPSILON" | "epsilon" )
                                        | ( "HUGE" | "huge" )
                                        | ( "MAXEXPONENT" | "maxexponent" )
                                        | ( "MINEXPONENT" | "minexponent" )
                                        | ( "PRECISION" | "precision" )
                                        | ( "RADIX" | "radix" )
                                        | ( "RANGE" | "range" )
                                        | ( "TINY" | "tiny" )
                                        ;

intrinsic_array_inquiry_function_name = ( "LBOUND" | "lbound" )
                                      | ( "SHAPE" | "shape" )
                                      | ( "SIZE" | "SIZE" )
                                      | ( "UBOUND" | "ubound" )
                                      ;

intrinsic_other_inquiry_function_name = ( "ALLOCATED" | "allocated" )
                                      | ( "ASSOCIATED" | "associated" )
                                      | ( "BIT_SIZE" | "bit_size" )
                                      | ( "EXTENDS_TYPE_OF" | "extends_type_of" )
                                      | ( "LEN" | "len" )
                                      | ( "NEW LINE" | "new line" )
                                      | ( "PRESENT" | "present" )
                                      | ( "SAME_TYPE_AS" | "same_type_as" )
                                      ;

intrinsic_bit_manipulation_function_name = ( "BTEST" | "btest" )
                                         | ( "IAND" | "iand" )
                                         | ( "IBCLR" | "ibclr" )
                                         | ( "IBITS" | "ibits" )
                                         | ( "IBSET" | "ibset" )
                                         | ( "IEOR" | "ieor" )
                                         | ( "IOR" | "ior" )
                                         | ( "ISHFT" | "ishft" )
                                         | ( "ISHFTC" | "ishftc" )
                                         | ( "MVBITS" | "mvbits" )
                                         | ( "NOT" | "not" )
                                         ;

intrinsic_floating_point_function_name = ( "EXPONENT" | "exponent" )
                                       | ( "FRACTION" | "fraction" )
                                       | ( "NEAREST" | "nearest" )
                                       | ( "RRSPACING" | "rrspacing" )
                                       | ( "SCALE" | "scale" )
                                       | ( "SET_EXPONENT" | "set_exponent" )
                                       | ( "SPACING" | "spacing" )
                                       ;

intrinsic_vector_matrix_function_name = ( "DOT_PRODUCT" | "dot_product" )
                                      | ( "MATMUL" | "matmul" )
                                      ;

intrinsic_array_reduction_function_name = ( "ALL" | "all" )
                                        | ( "ANY" | "any" )
                                        | ( "COUNT" | "count" )
                                        | ( "MAXVAL" | "maxval" )
                                        | ( "MINVAL" | "minval" )
                                        | ( "PRODUCT" | "product" )
                                        | ( "SUM" | "sum" )
                                        ;

intrinsic_array_construction_function_name = ( "CSHIFT" | "cshift" )
                                           | ( "EOSHIFT" | "eoshift" )
                                           | ( "MERGE" | "merge" )
                                           | ( "PACK" | "pack" )
                                           | ( "RESHAPE" | "reshape" )
                                           | ( "SPREAD" | "spread" )
                                           | ( "TRANSPOSE" | "transpose" )
                                           | ( "UNPACK" | "unpack" )
                                           ;

intrinsic_array_location_function_name = ( "MAXLOC" | "maxloc" )
                                       | ( "MINLOC" | "minloc" )
                                       ;

intrinsic_null_function_name = ( "NULL" | "null" )
                             ;

intrinsic_allocation_transfer_function_name = ( "MOVE_ALLOC" | "move_alloc" )
                                            ;

intrinsic_random_number_function_name = ( "RANDOM_NUMBER" | "random_number" )
                                      | ( "RANDOM_SEED" | "random_seed" )
;

intrinsic_system_environment_function_name = ( "COMMAND_ARGUMENT_COUNT" | "command_argument_count" )
                                           | ( "CPU_TIME" | "cpu_time" )
                                           | ( "DATE_AND_TIME" | "date_and_time" )
                                           | ( "GET_COMMAND" | "get_command" )
                                           | ( "GET_COMMAND_ARGUMENT" | "get_command_argument" )
                                           | ( "GET_ENVIRONMENT_VARIABLE" | "get_environment_variable" )
                                           | ( "IS_IOSTAT_END" | "is_iostat_end" )
                                           | ( "IS_IOSTAT_EOR" | "is_iostat_eor" )
                                           | ( "SYSTEM_CLOCK" | "system_clock" )
                                           ;
